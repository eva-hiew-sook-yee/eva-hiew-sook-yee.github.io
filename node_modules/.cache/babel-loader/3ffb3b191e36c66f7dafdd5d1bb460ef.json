{"ast":null,"code":"import React, { useRef, useEffect, memo } from 'react';\n\nasync function type(node) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  for (const arg of args) {\n    switch (typeof arg) {\n      case 'string':\n        await edit(node, arg);\n        break;\n\n      case 'number':\n        await wait(arg);\n        break;\n\n      case 'function':\n        await arg(node, ...args);\n        break;\n\n      default:\n        await arg;\n    }\n  }\n}\n\nasync function edit(node, text) {\n  const overlap = getOverlap(node.textContent, text);\n  await perform(node, [...deleter(node.textContent, overlap), ...writer(text, overlap)]);\n}\n\nasync function wait(ms) {\n  await new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function perform(node, edits) {\n  let speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n  for (const op of editor(edits)) {\n    op(node);\n    await wait(speed + speed * (Math.random() - 0.5));\n  }\n}\n\nfunction* editor(edits) {\n  for (const edit of edits) {\n    yield node => requestAnimationFrame(() => node.textContent = edit);\n  }\n}\n\nfunction* writer(_ref2) {\n  let [...text] = _ref2;\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : text.length;\n\n  while (startIndex < endIndex) {\n    yield text.slice(0, ++startIndex).join('');\n  }\n}\n\nfunction* deleter(_ref3) {\n  let [...text] = _ref3;\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : text.length;\n\n  while (endIndex > startIndex) {\n    yield text.slice(0, --endIndex).join('');\n  }\n}\n\nfunction getOverlap(start, _ref4) {\n  let [...end] = _ref4;\n  return [...start, NaN].findIndex((char, i) => end[i] !== char);\n}\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".styles_type__2Teeh::after {\\r\\n  content: '|';\\r\\n  animation: styles_cursor__14ty0 1.1s infinite step-start;\\r\\n}\\r\\n\\r\\n@keyframes styles_cursor__14ty0 {\\r\\n  50% {\\r\\n    opacity: 0;\\r\\n  }\\r\\n}\\r\\n\";\nvar styles = {\n  \"type\": \"styles_type__2Teeh\",\n  \"cursor\": \"styles_cursor__14ty0\"\n};\nstyleInject(css);\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar TypeAnimation = function TypeAnimation(_ref) {\n  var sequence = _ref.sequence,\n      repeat = _ref.repeat,\n      className = _ref.className,\n      _ref$wrapper = _ref.wrapper,\n      wrapper = _ref$wrapper === undefined ? 'p' : _ref$wrapper,\n      _ref$cursor = _ref.cursor,\n      cursor = _ref$cursor === undefined ? true : _ref$cursor;\n  var typeRef = useRef(null);\n  var baseStyle = styles.type;\n  var finalClassName = void 0;\n\n  if (className && className.length > 0) {\n    if (!cursor) {\n      finalClassName = className;\n    } else {\n      finalClassName = baseStyle + ' ' + className;\n    }\n  } else {\n    if (!cursor) {\n      finalClassName = '';\n    } else {\n      finalClassName = baseStyle;\n    }\n  }\n\n  useEffect(function () {\n    if (repeat === Infinity) {\n      type.apply(undefined, [typeRef.current].concat(toConsumableArray(sequence), [type]));\n    } else if (typeof repeat === 'number') {\n      type.apply(undefined, [typeRef.current].concat(toConsumableArray(Array(repeat).fill(sequence).flat())));\n    } else {\n      type.apply(undefined, [typeRef.current].concat(toConsumableArray(sequence)));\n    }\n  });\n  var Wrapper = wrapper;\n  return React.createElement(Wrapper, {\n    className: finalClassName,\n    ref: typeRef\n  });\n};\n\nvar index = memo(TypeAnimation);\nexport default index;","map":null,"metadata":{},"sourceType":"module"}